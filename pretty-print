#!/usr/bin/env gawk -f

BEGIN {
  styles()

  if (ARGC == 1 && system("test -t 0") == 0) {
    print_usage()
    exit 0
  }
}

/^Installing|^Configuring|^Retrieving/ {
  show(CR CLEAR_LINE STEP $0 RESET)
  next
}

/^Select/ {
  show(CR CLEAR_LINE CHOOSE $0 RESET)
  next
}

/^Invalid/ {
  show(CR CLEAR_LINE WARNING $0 RESET)
  next
}

/^Done/ {
  show(CR CLEAR_LINE DONE $0 RESET)
  next
}

{
  if (match($0, /^building '([^']+)'\.\.\.$/, arr)) {
    show(CR CLEAR_LINE PROGRESS_BADGE SPACE DIM "building" SPACE DIM "'" PATH arr[1] RESET DIM "'" "...")
    next
  }
}

{
  if (match($0, /^copying path '([^']+)' from '([^']+)'\.\.\.$/, arr)) {
    show(CR CLEAR_LINE PROGRESS_BADGE SPACE \
      DIM "copying path" SPACE DIM "'" PATH arr[1] RESET DIM "'" SPACE "from" SPACE "'" URL arr[2] RESET DIM "'" "...")
    next
  }
}

{
  if (match($0, /^unpacking '([^']+)'\.\.\.$/, arr)) {
    show(CR CLEAR_LINE PROGRESS_BADGE SPACE DIM "unpacking" SPACE DIM "'" URL arr[1] RESET DIM "'" "...")
    next
  }
}

{
  show(CR CLEAR_LINE INFO_BADGE SPACE $0 RESET)
  next
}

END {
  # Print optional completion message in color if non-empty
  if (completion != "") {
    show(CR CLEAR_LINE DONE completion RESET LF)
  }
  else {
    show(LF)
  }
}

function print_usage(    self) {
    self = script_name()

    ORS = "\n"

    print HEADER "Usage" RESET
    print "  " BOLD self RESET " [options] < input"
    print ""

    print HEADER "Description" RESET
    print "  " INFO "Formats and colorizes build output." RESET
    print ""

    print HEADER "Environment" RESET
    print "  " INFO "NO_COLOR" RESET "      Disable ANSI colors"
    print ""

    print INFO_BADGE " Reads from stdin and writes to stdout " RESET
}

function show(line) {
  if (tty && cols > 0) line = truncate_ansi(line, cols-1)
  print line
  if (tty) fflush()
}

function styles() {
  ORS = ""

  tty = (system("test -t 1") == 0)
  if (tty) { cols = terminal_capability("cols"); if (cols <= 0) cols = 80 } else { cols = 0 }

  CR = "\r"
  LF = "\n"
  SPACE = " "

  RESET      = terminal_capability("sgr0")
  CLEAR_LINE = terminal_capability("el")

  BOLD       = terminal_capability("bold")
  BOLD_OFF = "\033[22m"

  UNDERLINE  = terminal_capability("smul")
  UNDERLINE_OFF = terminal_capability("rmul")

  # Standard foreground colors
  BLACK_FG   = foreground_color("black")
  RED_FG     = foreground_color("red")
  GREEN_FG   = foreground_color("green")
  YELLOW_FG  = foreground_color("yellow")
  BLUE_FG    = foreground_color("blue")
  MAGENTA_FG = foreground_color("magenta")
  CYAN_FG    = foreground_color("cyan")
  WHITE_FG   = foreground_color("white")

  # Standard background colors
  BLACK_BG   = background_color("black")
  RED_BG     = background_color("red")
  GREEN_BG   = background_color("green")
  YELLOW_BG  = background_color("yellow")
  BLUE_BG    = background_color("blue")
  MAGENTA_BG = background_color("magenta")
  CYAN_BG    = background_color("cyan")
  WHITE_BG   = background_color("white")

  # Bright foreground colors
  BRIGHT_BLACK_FG   = bright_foreground_color("black")
  BRIGHT_RED_FG     = bright_foreground_color("red")
  BRIGHT_GREEN_FG   = bright_foreground_color("green")
  BRIGHT_YELLOW_FG  = bright_foreground_color("yellow")
  BRIGHT_BLUE_FG    = bright_foreground_color("blue")
  BRIGHT_MAGENTA_FG = bright_foreground_color("magenta")
  BRIGHT_CYAN_FG    = bright_foreground_color("cyan")
  BRIGHT_WHITE_FG   = bright_foreground_color("white")

  # Bright background colors
  BRIGHT_BLACK_BG   = bright_background_color("black")
  BRIGHT_RED_BG     = bright_background_color("red")
  BRIGHT_GREEN_BG   = bright_background_color("green")
  BRIGHT_YELLOW_BG  = bright_background_color("yellow")
  BRIGHT_BLUE_BG    = bright_background_color("blue")
  BRIGHT_MAGENTA_BG = bright_background_color("magenta")
  BRIGHT_CYAN_BG    = bright_background_color("cyan")
  BRIGHT_WHITE_BG   = bright_background_color("white")

  # Output layer semantics
  # Outcome = SUCCESS, DONE, ERROR
  # Flow = STEP, PROGRESS, SKIP
  # Signal Strength = INFO -> NOTICE -> WARNING -> ERROR

  # Structure semantics
  DIM     = BRIGHT_BLACK_FG       # for boilerplate or noisy lines
  HEADER  = BOLD BRIGHT_BLUE_FG
  SECTION = BOLD BRIGHT_WHITE_FG  # mini-header

  # Prompt semantics
  CHOICE        = BOLD BRIGHT_MAGENTA_FG
  PROMPT        = BOLD BRIGHT_CYAN_FG
  CHOICE_BADGE  = BRIGHT_MAGENTA_BG BRIGHT_WHITE_FG BOLD " CHOOSE " RESET
  PROMPT_BADGE  = BRIGHT_CYAN_BG BLACK_FG BOLD " ? " RESET

  # Flow semantics
  INFO           = BRIGHT_CYAN_FG
  PROGRESS       = BRIGHT_BLUE_FG         # for ongoing work that isn't success yet
  STEP           = BOLD BRIGHT_MAGENTA_FG # marks transitions between phases
  INFO_BADGE     = BRIGHT_BLUE_BG BRIGHT_WHITE_FG BOLD " INFO " RESET
  PROGRESS_BADGE = BRIGHT_BLUE_BG BRIGHT_WHITE_FG BOLD " RUN " RESET
  STEP_BADGE     = BRIGHT_MAGENTA_BG BRIGHT_WHITE_FG BOLD " STEP " RESET

  # Outcome semantics
  DONE          = BOLD BRIGHT_GREEN_FG  # for final completion
  ERROR         = BOLD BRIGHT_RED_FG
  SUCCESS       = BRIGHT_GREEN_FG
  WARNING       = BOLD BRIGHT_YELLOW_FG UNDERLINE
  DONE_BADGE    = BRIGHT_GREEN_BG BRIGHT_WHITE_FG BOLD " DONE " RESET
  ERROR_BADGE   = BRIGHT_RED_BG BRIGHT_WHITE_FG BOLD " ERROR " RESET
  SUCCESS_BADGE = GREEN_BG BLACK_FG BOLD " OK " RESET
  WARNING_BADGE = BRIGHT_YELLOW_BG BLACK_FG BOLD " WARN " RESET

  # Information density semantics
  NOTICE        = BRIGHT_WHITE_FG   # for deprecations, behavioral changes
  DEBUG         = BRIGHT_BLACK_FG   # muted, intentionally low contrast, use with DEBUG=1 env toggle
  SKIP          = BRIGHT_CYAN_FG    # for skipped steps or cached results
  DEBUG_BADGE   = BLACK_BG BRIGHT_WHITE_FG " DEBUG " RESET
  NOTICE_BADGE  = WHITE_BG BLACK_FG BOLD " NOTE " RESET
  SKIP_BADGE    = BRIGHT_CYAN_BG BLACK_FG BOLD " SKIP " RESET

  # Data-oriented semantics
  PATH 	= BOLD BRIGHT_WHITE_FG       # highlights filesystem paths
  URL 	= UNDERLINE BRIGHT_BLUE_FG   # highlights URLs
  VALUE = BRIGHT_MAGENTA_FG          # for numbers, sizes, versions, timings
}

function basename(path,    n, a) {
    n = split(path, a, "/")
    return a[n]
}

function script_name(    s) {
    s = ENVIRON["_"]

    # If ENVIRON["_"] is missing or just points at gawk, fall back
    if (s == "" || s ~ /(^|\/)gawk$/)
        s = ARGV[0]

    return basename(s)
}

function background_color(name) {
  return terminal_color(name, 1)
}

function foreground_color(name) {
  return terminal_color(name, 0)
}

function terminal_color(name, is_bg,    colors, color_map) {
    split("black red green yellow blue magenta cyan white", colors, " ")
    for (i in colors) color_map[colors[i]] = i - 1

    if (name in color_map) {
        capability = (is_bg) ? "setab " : "setaf "
        return terminal_capability(capability color_map[name])
    }
    return ""
}

function bright_foreground_color(name) {
  return terminal_bright_color(name, 0)
}

function bright_background_color(name) {
  return terminal_bright_color(name, 1)
}

function terminal_bright_color(name, is_bg,    colors, color_map) {
  split("black red green yellow blue magenta cyan white", colors, " ")
  for (i in colors) color_map[colors[i]] = i - 1

  if (name in color_map) {
    # Many terminfo entries expose bright colors as setaf/setab + 8
    capability = (is_bg) ? "setab " : "setaf "
    return terminal_capability(capability (color_map[name] + 8))
  }
  return ""
}

function terminal_capability(capability,    output, status) {
    if (ENVIRON["NO_COLOR"]) return ""
    cmd = "tput " capability
    status = (cmd | getline output)
    close(cmd)
    return (status > 0) ? output : ""
}

function truncate_ansi(s, max,    out, i, c, esc, vis) {
  out = ""; esc = 0; vis = 0
  for (i = 1; i <= length(s); i++) {
    c = substr(s, i, 1)
    if (esc) { out = out c; if (c ~ /[A-Za-z]/) esc = 0; continue }
    if (c == "\033") { esc = 1; out = out c; continue }
    if (vis >= max) break
    out = out c; vis++
  }
  return out
}
